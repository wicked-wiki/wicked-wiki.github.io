{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome","title":"Welcome!","text":"<p>The goal of this resource is to supplement the existing documentation found at the official Github repo. This site contains a collection of source code examples that you may freely copy and paste into a source file, build, run and tinker with for your own projects. All source code examples from this site are expressly under the MIT license.</p>"},{"location":"#target-audience-prerequisite-knowledge","title":"Target Audience &amp; Prerequisite Knowledge","text":"<p>It is strongly recommended to have at least some working knowledge of the C++ programming language and familiarity with Visual Studio.  As of this writing the primary focus of these examples will be for C++ related projects, but the examples will eventually branch out to include Lua scripting as well.</p> <p>While it might not be necessary to have experience with other game engine frameworks, having experience with Entity-Component-System software architecture is certainly an asset. Additionally, Wicked Engine is hosted on Github, so naturally understanding some minimal core concepts like cloning, branching and merging will be needed.</p> <p>Depending on your experience as a developer, you may find the official documentation and Github repo more than sufficient to get you started on using Wicked Engine. However, if you are relatively new to game development or if your area of expertise is more rooted in domains outside of programming, I hope this resource is useful to help you get started quickly!</p>"},{"location":"#format","title":"Format","text":"<p>This wiki is loosely structured and generally organized by an article per topic, such as the individual components, important functions and helper classes.</p> <p>These articles will contain minimal but complete code snippets intended to serve as a functioning working example. As of this writing (for the time being) this wiki will instruct you how to adapt the existing \"Template_Windows\" project sample. Depending on feedback I receive, I might create a branch on my own fork of Wicked containing an additional project setup specifically for these examples to hopefully make the process even easier.</p>"},{"location":"#feedback","title":"Feedback","text":"<p>I welcome any questions, comments and especially content submissions! Please reach out to me on Discord <code>@twisty3780</code>, preferably on the official Wicked Engine discord server. As of this writing there is a dedicated channel for this wiki and other documentation in #wiki-and-documentation.</p> <p>Unless absolutely necessary, please do not contact or tag anyone specifically within operations over the content found on this site as this is an unofficial wiki written by me. Every effort will be made to ensure correctness and functionality of the examples, but they are not responsible for my mistakes.</p>"},{"location":"getstarted/","title":"Getting Started","text":""},{"location":"getstarted/#clone-and-build","title":"Clone and Build","text":"<p>After you have cloned the repo, you will want to create a release build of the engine library and the Editor. The engine is entirely self contained and does not have any external dependancies; its build process is painless. Once complete, navigate to <code>BUILD\\x64\\Release\\Editor_Windows</code> and it will be named <code>Editor_Windows.exe</code>. I like to create a shortcut to this on my desktop.</p> <p>The Visual Studio solution will contain a <code>Samples</code> folder and a project <code>Template_Windows</code>. This will be the starting point for your game or app, so if it isn't set already, right click on the template in the solution explorer and set it as your startup project.</p>"},{"location":"getstarted/#project-prep","title":"Project Prep","text":"<p>The Windows template ships with only a single file: <code>main.cpp</code>. This file contains an implementation of a Windows main function with all the necessary boilerplate and message handling loop for a Windows application to function, and to provide a bridge for Wicked Engine to work as an application. The important takeaway here is that effort was made in this file to separate what your game logic does with Wicked from how your operating system facilitates it.</p> <p>Should you build and run this project now, you'll be greeted with a windowed black screen. It will compile some shaders, show some version information and other statistics, but in a few moments it will ultimately settle down to a steady 60fps stream of endless nothing.</p> <p>Lets change that!</p> <p></p> <p>Despite how scary most of the code in that file might look, this project is conveniently written such that only a minor change near the beginning is really needed for us to start doing our own thing. At the top you will see the following:</p> <pre><code>#include \"WickedEngine.h\"\n\nwi::Application application;\n</code></pre> <p>As we've seen, Wicked intentionally does the bare minimum by default in its current state. What we need to do is derive our own <code>wi::Application</code> class and derive another class for something called a renderpath, specifically <code>wi::RenderPath3D</code>. Let's come back to this file a bit later.</p>"},{"location":"getstarted/#gameh","title":"game.h","text":"<p>Create a header file called <code>game.h</code> and give it the following:</p> <pre><code>#include \"WickedEngine.h\"\n\nclass GameRenderPath : public wi::RenderPath3D {\npublic:\n    void Load() override;\n    void Update(float dt) override;\n};\n\nclass GameApp : public wi::Application{\npublic:\n    GameRenderPath renderer;\n    void Initialize() override;\n};\n</code></pre> <p>As you can tell, we are gearing up for a 3D application where we will need to override the methods <code>Initialize()</code>, <code>Load()</code> and <code>Update()</code>.  If you inspect the engine headers you will find others, but for now we can just focus on these.</p>"},{"location":"getstarted/#app_initcpp","title":"app_init.cpp","text":"<p>In an effort to try keep things simple, minimal and managible for the purposes of the content on this site, I would like to separate our application methods from those belonging to our renderpath. This is because the content in <code>Initialize()</code> will change less frequently than what will be found in <code>Load()</code> and <code>Update()</code></p> <p>Let's create a source file named <code>app_init.cpp</code> and give it the following:</p>"},{"location":"getstarted/#initialize","title":"Initialize()","text":"<pre><code>#include \"game.h\"\n\nvoid GameApp::Initialize() {\n    wi::Application::Initialize();\n\n    renderer.init(canvas);\n    renderer.Load();\n\n    ActivatePath(&amp;renderer);\n}\n</code></pre> <p>Without going into details (because I don't pretend to know them!) this method is used to introduce the renderpath to our application's <code>canvas</code>, presumably to give the renderer something to draw upon. These pleasantries continue with the base application class method <code>ActivatePath()</code> being provided with our derived <code>GameRenderPath</code> class object named <code>renderer</code>.</p>"},{"location":"getstarted/#gamecpp","title":"game.cpp","text":"<p>Now let's create the star of the show, <code>game.cpp</code>. This will contain the following two methods:</p>"},{"location":"getstarted/#load","title":"Load()","text":"<pre><code>#include \"game.h\"\n\nvoid GameRenderPath::Load() {\n    // Content is loaded here!  \n    RenderPath3D::Load();\n}\n</code></pre> <p>There isn't much in this method just yet, but for right now paste it like this and we will return to it soon.</p>"},{"location":"getstarted/#update","title":"Update()","text":"<pre><code>void GameRenderPath::Update(float dt) {\n    // Do something every frame!    \n    RenderPath3D::Update(dt);\n}\n</code></pre> <p>Similar to above, the bare minimum is here. More to come later.</p>"},{"location":"getstarted/#maincpp","title":"main.cpp","text":"<p>Let's double back to <code>main.cpp</code>. Remember how it created the <code>application</code> object from <code>wi::Application</code>? We now have our own derived class, so now we include our <code>game.h</code> header and switch out the class:</p> <pre><code>#include \"WickedEngine.h\"\n#include \"game.h\"\n\nGameApp application;\n</code></pre>"},{"location":"getstarted/#checkpoint","title":"Checkpoint","text":""},{"location":"getstarted/#sanity-check","title":"Sanity Check","text":"<p>If all goes well (and you might have already guessed) we should be enjoying another visit from our old friend, the empty black screen. I promised to change that, however this is an important milestone: If you find yourself struggling at this point in the tutorial and have no idea what is going on, it might be best to do some intro courses on C++ using Visual Studio and then come back to tackle this. Otherwise, I can personally guarantee much hair pulling and shouting ancient nordic curses at your IDE.</p>"},{"location":"getstarted/#content","title":"Content","text":"<p>Now that we've refactored the standard issue Windows template a little bit, we can get to the fun stuff: adding content!</p> <p>Inside your cloned repo, there will be a folder named <code>Content/models</code> which will have a number of goodies in various file formats. As far as 3D models go, you will likely recognize some <code>.obj</code> and <code>.glb</code> files contained therein, but there will be a brand new one: Wicked's own <code>.wiscene</code> file. Functionally, these are archived scenes containing models, materials, animations, sounds and any other content that Wicked Engine can immediately use.</p> <p>Now would be a good time to fire up the Wicked Editor you freshly compiled and take a peek inside some of this content.</p> <p>The Editor is very nicely documented so I won't spend much time describing how it works. However, I think you will find it is fairly intuitive, and inspecting the files in the models folder is as easy as dragging and dropping them right in.</p> <p>When you're done poking around, either restart the editor, or clear the current scene by clicking the 'x' on the tab in the upper left. Let's have a look at <code>teapot.wiscene</code> and inspect its contents. On the right hand side in the Entities panel, you will see all of the entities that make up this scene and some icons for their attached components. All of the components and data is stored below.</p> <p>I would like to bring your attention to two in particular, one named \"Base\" and the other named \"Top\". They are so named because they have a name component, and you will see they have several other associated components enabling you to do interesting things with them.</p> <p></p>"},{"location":"getstarted/#loadmodel","title":"LoadModel()","text":"<p>Let's bring this scene into our in-game world and try a few things out by using <code>LoadModel()</code>. Navigate back to your <code>game.cpp</code> source file and make the following changes:</p> <pre><code>#include \"game.h\"\n\nusing namespace wi::scene;\n\nvoid GameRenderPath::Load() {\n    // Content is loaded here!\n    LoadModel(\"../../Content/models/teapot.wiscene\");\n\n    RenderPath3D::Load();\n}\n\nvoid GameRenderPath::Update(float dt) {\n    // Do something every frame!\n    RenderPath3D::Update(dt);\n}\n</code></pre> <p>Compile and run and we should now see something like this:</p> <p></p> <p>At first glance is a bit unclear what is going on, but what we are viewing is the bottom of the teapot. The default position of the camera is at the world origin, which just so happens to be where the teapot model is roughly positioned.</p>"},{"location":"getstarted/#camera","title":"Camera","text":"<p>To get a better view, let's move the camera back a little bit and up slightly. Modify the <code>Load()</code> function as shown:</p> <p><pre><code>void GameRenderPath::Load() {\n    LoadModel(\"../../Content/models/teapot.wiscene\");\n\n    // Create a transform to reposition the camera\n    TransformComponent transform;\n    transform.Translate(XMFLOAT3(0.0f, 1.0f, -4.0f));\n    GetCamera().TransformCamera(transform);\n\n    RenderPath3D::Load();\n}\n</code></pre> Compile and run, much better!</p> <p></p>"},{"location":"getstarted/#moving-things","title":"Moving Things","text":"<p>Recall when we used the Editor to view the teapot scene we identified the two objects for the top and base of the teapot? Lets try moving the top by first finding it by its name, and then working with its <code>TransformComponent</code>. Consider the following changes to the <code>Load()</code> method:</p> <pre><code>using namespace wi::scene;\nusing namespace wi::ecs;\n\nvoid GameRenderPath::Load() {\n    LoadModel(\"../../Content/models/teapot.wiscene\");\n\n    // Create a transform to reposition the camera\n    TransformComponent transform;\n    transform.Translate(XMFLOAT3(0.0f, 1.5f, -4.0f));\n    transform.UpdateTransform();\n    GetCamera().TransformCamera(transform);\n\n    // Move the lid up!\n    Entity ent_top = GetScene().Entity_FindByName(\"Top\");\n    TransformComponent* trans_top = GetScene().transforms.GetComponent(ent_top);\n    trans_top-&gt;Translate(XMFLOAT3(0.0f, 0.6f, 0.0f));\n\n    RenderPath3D::Load();\n}\n</code></pre> <p>Check your returns!</p> <p>Keep in mind that absolutely no error checking is being carried out. If the entity cannot be found by name, you will end up with <code>wi::ecs::INVALID_ENTITY</code> which is zero. If the entity is invalid or does not have a component you are attempting to get, you will receive a null pointer.</p> <p>The additional <code>wi::ecs</code> namespace has been added for the <code>Entity</code> type, which is simply a 64-bit unsigned number.</p> <p>On line 14 we get the global scene to find our entity by name with <code>Entity_FindByName()</code>. Next, we fetch the <code>TransformComponent</code> pointer specific to the Entity we were given. Finally, we call the <code>Translate()</code> method on that object to slightly move the the lid up on the Y axis.</p> <p></p> <p>Finally, let's add some code to slowly move the lid upward a little bit every frame. Make the following changes to <code>GameApp::Update()</code>:</p> <pre><code>void GameRenderPath::Update(float dt) {\n    Entity ent_teapot_top = GetScene().Entity_FindByName(\"Top\");\n    TransformComponent* trans_teapot = GetScene().transforms.GetComponent(ent_teapot_top);\n    trans_teapot-&gt;Translate(XMFLOAT3(0.0f, 0.01f, 0.0f));\n\n    RenderPath3D::Update(dt);\n}\n</code></pre>"},{"location":"getstarted/#congrats","title":"Congrats!","text":"<p>You've taken your first steps into making some content using Wicked Engine! If you have any comments on this tutorial or have some suggestions for future tutorials, please head over to #wiki-and-documentation on the Wicked Discord server.</p>"}]}